// qobject.sip generated by MetaSIP on Wed Aug 21 06:30:43 2013
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


typedef QList<QObject*> QObjectList;

class QObject 
{
%TypeHeaderCode
#include <qobject.h>
%End

%TypeHeaderCodeD
import std.string: format;
import std.variant;
import std.algorithm: find;
import std.array: split;

class SlotException: Exception {
    this(string message) {
        super(message);
    }
}
%End

%TypeBodyCodeD
    QObject receiver;
    string slotName;
    
    final void connect(QObject sender, string signal, QObject receiver, string member) {
        bool success = simpleConnect(sender, signal, receiver, member);
        if (success) return;
        writeln("connect D ", signal, " ", member);
        slotName = member;
        this.receiver = receiver;
    }
    
    final void emit(string signalName, T...)(T args) {
        writeln("emit ", signalName, " ", args);
        Variant[] v;
        foreach(arg; args) {
            v ~= Variant(arg);
        }
        auto slotName = slotName[1 .. $];
        if (slotName.find("(")) {
            slotName = slotName.split("(")[0];
        }
        receiver.activate(slotName, v);
    }
    
    bool activate(string slotName, Variant[] args) {
        string message = "%s could not run slot %s with args %s".format(this, slotName, args);
        throw new SlotException(message);
    }
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QCoreApplication, &sipType_QCoreApplication, -1, 1},
        {sipName_QEventLoop, &sipType_QEventLoop, -1, 2},
        {sipName_QAbstractItemModel, &sipType_QAbstractItemModel, 24, 3},
        {sipName_QSignalMapper, &sipType_QSignalMapper, -1, 4},
        {sipName_QTimer, &sipType_QTimer, -1, 5},
        {sipName_QThread, &sipType_QThread, -1, 6},
        {sipName_QTranslator, &sipType_QTranslator, -1, 7},
        {sipName_QObjectCleanupHandler, &sipType_QObjectCleanupHandler, -1, 8},
        {sipName_QThreadPool, &sipType_QThreadPool, -1, 9},
        {sipName_QSharedMemory, &sipType_QSharedMemory, -1, 10},
        {sipName_QAbstractState, &sipType_QAbstractState, 30, 11},
        {sipName_QFileSystemWatcher, &sipType_QFileSystemWatcher, -1, 12},
        {sipName_QAbstractTransition, &sipType_QAbstractTransition, 34, 13},
        {sipName_QAbstractAnimation, &sipType_QAbstractAnimation, 36, 14},
    #if defined(Q_OS_WIN)
        {sipName_QWinEventNotifier, &sipType_QWinEventNotifier, -1, 15},
    #else
        {0, 0, -1, 15},
    #endif
        {sipName_QItemSelectionModel, &sipType_QItemSelectionModel, -1, 16},
        {sipName_QPluginLoader, &sipType_QPluginLoader, -1, 17},
        {sipName_QSocketNotifier, &sipType_QSocketNotifier, -1, 18},
        {sipName_QMimeData, &sipType_QMimeData, -1, 19},
        {sipName_QIODevice, &sipType_QIODevice, 42, 20},
        {sipName_QAbstractEventDispatcher, &sipType_QAbstractEventDispatcher, -1, 21},
        {sipName_QTimeLine, &sipType_QTimeLine, -1, 22},
        {sipName_QLibrary, &sipType_QLibrary, -1, 23},
        {sipName_QSettings, &sipType_QSettings, -1, -1},
        {sipName_QAbstractListModel, &sipType_QAbstractListModel, 27, 25},
        {sipName_QAbstractProxyModel, &sipType_QAbstractProxyModel, 28, 26},
        {sipName_QAbstractTableModel, &sipType_QAbstractTableModel, -1, -1},
        {sipName_QStringListModel, &sipType_QStringListModel, -1, -1},
        {sipName_QIdentityProxyModel, &sipType_QIdentityProxyModel, -1, 29},
        {sipName_QSortFilterProxyModel, &sipType_QSortFilterProxyModel, -1, -1},
        {sipName_QHistoryState, &sipType_QHistoryState, -1, 31},
        {sipName_QState, &sipType_QState, 33, 32},
        {sipName_QFinalState, &sipType_QFinalState, -1, -1},
        {sipName_QStateMachine, &sipType_QStateMachine, -1, -1},
        {sipName_QEventTransition, &sipType_QEventTransition, -1, 35},
        {sipName_QSignalTransition, &sipType_QSignalTransition, -1, -1},
        {sipName_QAnimationGroup, &sipType_QAnimationGroup, 39, 37},
        {sipName_QVariantAnimation, &sipType_QVariantAnimation, 41, 38},
        {sipName_QPauseAnimation, &sipType_QPauseAnimation, -1, -1},
        {sipName_QSequentialAnimationGroup, &sipType_QSequentialAnimationGroup, -1, 40},
        {sipName_QParallelAnimationGroup, &sipType_QParallelAnimationGroup, -1, -1},
        {sipName_QPropertyAnimation, &sipType_QPropertyAnimation, -1, -1},
        {sipName_QFileDevice, &sipType_QFileDevice, 45, 43},
        {sipName_QProcess, &sipType_QProcess, -1, 44},
        {sipName_QBuffer, &sipType_QBuffer, -1, -1},
        {sipName_QFile, &sipType_QFile, 46, -1},
        {sipName_QTemporaryFile, &sipType_QTemporaryFile, -1, -1},
    };
    
    int i = 0;
    
    sipType = NULL;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End



public:
    static const QMetaObject staticMetaObject {
%GetCode
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
%End

    };
    const QMetaObject *metaObject() const;
    explicit QObject(QObject *parent /TransferThis/ = 0);
    virtual ~QObject();
    void pyqtConfigure(SIP_PYOBJECT) /NoArgParser/;

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
    QString tr(const char *sourceText /Encoding="UTF-8"/, const char *disambiguation = 0, int n = -1) const;
	const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection);
		
    static QMetaObject::Connection connect(const QObject *sender, const char *signal,
		const QObject *receiver, const char *member) /DName="_nativeConnect"/;		
		
	static bool isConnectionValid(QMetaObject::Connection* connection);
%MethodCodeD
    // cast to bool
    bool success = connection;
    return success;
%End

    static bool simpleConnect(const QObject *sender, const char *signal,
        const QObject *receiver, const char *member);
%MethodCodeD
    QMetaObject::Connection conn = QObject::connect(sender, signal, receiver, member);
    bool success = conn;
    return success;
%End

    QString objectName() const;
    void setObjectName(const QString &name);
    bool isWidgetType() const;
    bool isWindowType() const;
    bool signalsBlocked() const;
    bool blockSignals(bool b);
    QThread *thread() const;
    void moveToThread(QThread *thread);
    int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);
    void killTimer(int id);
    const QObjectList &children() const;
    void setParent(QObject * /TransferThis/);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);
    void dumpObjectInfo();
    void dumpObjectTree();
    QList<QByteArray> dynamicPropertyNames() const;
    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;

signals:
    void destroyed(QObject *object = 0);
    void objectNameChanged(const QString &objectName);

public:
    QObject *parent() const;
    bool inherits(const char *classname) const;

public slots:
    void deleteLater() /TransferThis/;

protected:
    QObject *sender() const /ReleaseGIL/;


    int receivers(SIP_PYOBJECT signal /DocType="signal"/) const [int (const char *signal)];

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);
    virtual void connectNotify(const QMetaMethod &signal);
    virtual void disconnectNotify(const QMetaMethod &signal);
    int senderSignalIndex() const;
    bool isSignalConnected(const QMetaMethod &signal) const;

public:
    SIP_PYOBJECT disconnect() const /DocType=""/;
%MethodCode
        sipRes = qpycore_qobject_disconnect(sipCpp);
%End

private:
    QObject(const QObject &);
};

SIP_PYOBJECT Q_CLASSINFO(const char *name, const char *value) /DocType=""/;
%MethodCode
    sipRes = qpycore_ClassInfo(a0, a1);
%End

SIP_PYOBJECT Q_ENUMS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT Q_FLAGS(...) /DocType=""/;
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TR_NOOP_UTF8(SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT /DocType="str"/, SIP_PYOBJECT /DocType="str"/) /DocType="str"/;
%MethodCode
    Py_INCREF(a1);
    sipRes = a1;
%End

SIP_PYOBJECT pyqtSlot(const char *signature, const char *name = 0, const char *result = 0) /NoArgParser/;
%Docstring
@pyqtSlot(*types, str name=None, str result=None)

This is a decorator applied to Python methods of a QObject that marks them
as Qt slots.
The non-keyword arguments are the types of the slot arguments and each may
be a Python type object or a string specifying a C++ type.
name is the name of the slot and defaults to the name of the method.
result is type of the value returned by the slot.
%End

%MethodCode
    return qpycore_pyqtslot(sipArgs, sipKwds);
%End

%ModuleHeaderCode
#include <qpycore_api.h>
%End

%ModuleCode
// Disable the (supposedly) compulsory parts of the Qt support API.
#define sipQtCreateUniversalSlot    0
#define sipQtDestroyUniversalSlot   0
#define sipQtFindSlot               0
#define sipQtConnect                0
#define sipQtDisconnect             0
#define sipQtSameSignalSlotName     0
#define sipQtFindSipslot            0
%End

%InitialisationCode
qpycore_init();
%End

%PostInitialisationCode
qpycore_post_init(sipModuleDict);
%End
